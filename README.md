# My Portfolio with React Plus Rails 5.2.6!

After working through my resume and portfolio site based on just React as a simple single page app on GithubPages, I knew I could still improve it technology wise. With a giant list of json files sitting in the src folder of my app, I automatically knew that a REST API would be exactly what the doctor ordered. Having heard a ton about Ruby on Rails and not having a lot of experience with Ruby itself, this seemed like a great opportunity to practice Ruby and play with a new backend framework! From that little idea, I ended up learning a ton more than I expected from git submodules to Rails routing and React proxying.

## Incoming Improvements
- Moving onto the Rails 6 version

## Notes about Deploying to Heroku

- There are currently two different versions of this app. One version uses Rails 6 with the API flag set, simply proxying over the React app's requests. Though this version can still use the proxy to handle requests from the React client, it was built using Rails 5.2.4.1 and happens to be a full Rails App that can serve and display its own routes without any help from React. Both versions had their challenges but this version had a particularly difficult to diagnose a problem due to the PIDFile, normally used to kill the server if needed. I had two options, either go to the puma config file and get rid of the line dedicated to specifying a PIDFile for the server or configure the gitignore file to track the tmp/pids directory via .keep file (.gitkeep would work as well). Since the latter seemed less destructive, I elected to go that route. Ultimately the solution to both 5.x & 6.x seems to be starting up the Rails end of things directly with Puma and a .env file as opposed to simply issuing a 'rails server' command in the heroku Procfile. With Rails 6 now using Webpacker instead of Sprockets to handle assets, a Rails 6 app in normal mode (instead of API only mode) would likely not play nicely with a React app made by create-react-app due to conflicting node_modules folders unless serious configuration care was taken.
  - Now with better understanding (except on PIDFiles), the best option in a monolith like this when dealing with Heroku is undoubtedly allowing React (or any other SPA framework that can create its own build) to create its production build and allow our backend to serve the main file. Doing this keeps the Rails end as a powerful API back-end, and the front-end can be a powerful front-end, only served up by the back-end, rather than as a separate app/service (forcing a CORS issue). As a bonus, neither Webpacker nor Sprockets should be needed!
    - Without Webpacker / Sprockets, lines like 'javascript_include_tag', 'javascript_pack_tag', or 'stylesheet_link_tag' in application.html.erb wouldn't work or be needed. Instead using the proxy for local dev (and React's hot reloading) would be all you need to handle updates EXCEPT in cases like ActiveAdmin.
      - When you do need them though Sprockets uses //= require while Webpacker uses import & require	in app/assets/javascript/application.js
